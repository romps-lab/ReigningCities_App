
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Resources;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.XR.ARFoundation;

/*
 *  REQUIRED
 */

public class ObjectSpawner : MonoBehaviour
{
    // VARIABLES TO MONITOR STATE OF THE CLASS
    bool placeNewObject;
    bool playGroundPlaced;
    bool playGroundTapDone;
    bool isTouched;

    // VARIABLES TO HOLD DATA GENERATED BY CLASS
    private List<GameObject> interactableObjects;
    private GameObject instantiatedPlayGround;
    private ARPlane hitPlane;
    private ARAnchor anchor;

    private Dictionary<string, Dictionary<string, List<float>>> sessionData;
    private static string TAG;
    private static string FILE;
    private static readonly string LOCAL_POSITION = "position";
    private static readonly string LOCAL_ROTATION = "rotation";
    private static readonly string LOCAL_SCALE = "scale";

    // TEMPORARY VARIABLES USED BY CLASS
    /* 
     * used when displacing current selected gameobject to new location 
     * int the world to store screen touch location and once job is done 
     * set this variable again to Vector2.zero
     */
    Vector2 previousTouchLocation; 
    /*
     * Should use different algorithm to get rid of this variable, as currently
     * 3D prespective is not considered while moving game object, so some research on 
     * camera FOV.
     */
    GameObject selectedInteractable;

    //CLASS TUNING PARAMETERS
    float gridSize = 0.2f;
    float movementSpeed = 2f;
    float rayTravelDistance = 200f; //i.e 200 mtrs in world


    [SerializeField] GameObject assetPrefab = null;
    [SerializeField] GameObject playGround = null;
    [SerializeField] GameObject markerPrefab = null;

    //DELEGATES USED BY THE CLASS
    private ARPlaneManager planeManager;
    private ARAnchorManager anchorManager;
    private ARRaycastManager rayCastManager;
    private Camera camera;

    private GameObject mainEntity;

    bool fetchLog;

    private void Start()
    {
        placeNewObject = false;
        playGroundPlaced = false;
        playGroundTapDone = false;
        isTouched = false;

        fetchLog = true;

        previousTouchLocation = Vector2.zero;
        selectedInteractable = null;

        interactableObjects = new List<GameObject>();

        planeManager = FindObjectOfType<ARPlaneManager>();
        anchorManager = FindObjectOfType<ARAnchorManager>();
        rayCastManager = FindObjectOfType<ARRaycastManager>();
        camera = FindObjectOfType<Camera>();

        sessionData = new Dictionary<string, Dictionary<string, List<float>>>();
        TAG = "ObjectSpawner";
        FILE = Application.persistentDataPath + "/" + TAG + "sessionData.json";
        fetchSessionDataFromFile(FILE);

        Debug.Log("Scale of assetFrefab : " + assetPrefab.transform.localScale);
    }

    private void Update()
    {
        if (EventSystem.current.IsPointerOverGameObject(Input.GetTouch(0).fingerId))
        {
            return;
        }

        if (!playGroundTapDone)
        {
            placePlayGroundFirst();
            return;
        }

        //placeNewObject toggle will only appear when one object is placed.
        if(interactableObjects.Count <= 0 || placeNewObject)
        {
            placeGameObjectOnPlayGround();
        }
        else if (!placeNewObject)
        {
            tryMovingObject();
        }

        if (fetchLog && playGroundTapDone )
        {
            //INFO ABOUT PLAY GROUND
            Debug.Log("Parent of Play Ground is :" + instantiatedPlayGround.transform.parent.name);
            Debug.Log("World coordinate position of Play Ground : " + instantiatedPlayGround.transform.position);
            Debug.Log("Local coordinate position of Play Ground :" + instantiatedPlayGround.transform.localPosition);
            Debug.Log("World coordinate rotation of Play Ground : " + instantiatedPlayGround.transform.rotation);
            Debug.Log("Local coordinate rotation of Play Ground :" + instantiatedPlayGround.transform.localRotation);
            Debug.Log("Local coordinate scale of Play Ground : " + instantiatedPlayGround.transform.localScale);

            //INFO ABOUT INTERACTABLE OBJECT
            foreach(GameObject interactableObject in interactableObjects)
            {
                Debug.Log("Parent of interactableObject is :" + interactableObject.transform.parent.name);
                Debug.Log("World coordinate position of interactableObject : " + interactableObject.transform.position);
                Debug.Log("Local coordinate position of interactableObject :" + interactableObject.transform.localPosition);
                Debug.Log("World coordinate rotation of interactableObject : " + interactableObject.transform.rotation);
                Debug.Log("Local coordinate rotation of interactableObject :" + interactableObject.transform.localRotation);
                Debug.Log("Local coordinate scale of interactableObject : " + interactableObject.transform.localScale);
            }
        }

    }

    private void placePlayGroundFirst()
    {
        Debug.Log("Place PlayGround First");
        if(Input.touches.Count() > 0)
        {   
            if( Input.touches[0].phase == TouchPhase.Ended  && playGroundPlaced)
            {
                playGroundTapDone = true;
                return;
            }

            if(playGroundPlaced) { return; }

            List<ARRaycastHit> hits = new List<ARRaycastHit>();
            rayCastManager.Raycast(
                Input.touches[0].position, 
                hits, 
                UnityEngine.XR.ARSubsystems.TrackableType.Planes
                );

            if(hits.Count > 0)
            {  
                planeManager.trackables.TryGetTrackable(
                    hits[hits.Count - 1].trackableId, 
                    out hitPlane
                    );
                if (hitPlane)
                {
                    //ARFOUNDATION does not attach anchor as soon as it recieves
                    //ATTACH ANCHOR request, infact it takes aditional 1 or 2 frames 
                    //to attach anchor to plane and once attached it gives callback.
                    //IN callback function we will actually place the play ground
                    anchorManager.anchorsChanged += anchorChangedCallback;

                    //always attach to ray hit pose and not to plane pose.
                    //as hit pose axis are alligned with camera.
                    anchor = anchorManager.AttachAnchor(hitPlane, hits[hits.Count - 1].pose);
                }
            }
            
        }
    }

    private void placeGameObjectOnPlayGround()
    {

        Debug.Log("Place GameObject First");
        if(Input.touches.Count() > 0 )
        {
            /*
             * Can remove below two "if" condition check, which restrict player
             * to deploy only one gameobject at time(considering the fact that in one 
             * TAP event there can be multiple touch events recorded). If below two 
             * "if" checks are removed write additional code that detect such gameobjects 
             * those got deployed at same location(in our case its grid) and remove them 
             * keeping only one gameobject at that particular location.
             * */
            if(Input.touches[0].phase == TouchPhase.Ended)
            {
                //RESET ALL STATE VARIABLES and TEMPERORY VARIABLLES USED
                isTouched = false;
                return;
            }
            if (isTouched)
            {
                return;
            }

            RaycastHit hit;
            Vector2 screenTouchLocation = Input.touches[0].position;
            if (isFingureTouchingPlaygroud(camera.ScreenPointToRay(screenTouchLocation) , out hit))
            {
                if (hit.distance > 0)
                {
                    //Debug.Log("Play Ground Hit at Location : " + hit.point);
                    Vector3 adjustedLocation = getAdjustedLocation(hit);
                    //Debug.Log("Forcefull swap location: " + adjustedLocation);

                    /*
                     * GameObject obj = Instantiate(assetPrefab, anchor.transform);
                     * Above line adds new asset as a child of playGround, which 
                     * affects the transform of new asset and not works as expected.
                     * Its better to use anchor as a parent.
                     */
                    assetPrefab = Resources.Load<GameObject>(ARScreenHelper.Instance.currentSupportEntity);
                    GameObject obj = Instantiate(assetPrefab, anchor.transform , false);
                    obj.transform.position = adjustedLocation;

                    Vector3 tempPos = obj.transform.position;
                    tempPos.y += obj.transform.localScale.y / 2;
                    obj.transform.position = tempPos;


                    obj.transform.position = tempPos;
                    interactableObjects.Add(obj);
                    updateSessionData(null);
                }
            }
            isTouched = true;
        }
    }

    private void tryMovingObject()
    {
        Debug.Log("Moving ");

        if (Input.touches.Count() > 0)
        {
            Vector2 currentScreenTouchPosition = Input.touches[0].position;

            if(Input.touches[0].phase == TouchPhase.Ended)
            {
                //RESET ALL STATE VARIABLES and TEMPERORY VARIABLLES USED
                previousTouchLocation = Vector2.zero;
                selectedInteractable = null;
                return;
            }

            if(Input.touches[0].phase == TouchPhase.Began)
            {
                //Use this phase to set previous touch location and selectedInteractable.
                if ((selectedInteractable = isFingureOverInteractables(currentScreenTouchPosition)) == null)
                {
                    return;
                }
                previousTouchLocation = Input.touches[0].position;
            }
            else
            {
               
                /*
                 * Use this phase to make selected gameobject
                 * If execution reaches to this block it's gaurenteed that
                 * "selectedInteractable" and "previousTouchLocation" variables 
                 * hold appropriate values
                 */
                RaycastHit hitOnPlayGround;
                if (isTouchWithinPlayGround(currentScreenTouchPosition , out hitOnPlayGround))
                {
                    Vector3 adjustedLocation = getAdjustedLocation(hitOnPlayGround);
                    selectedInteractable.transform.position = adjustedLocation;
                }
                updateSessionData(null);
            }
        }

    }


    private GameObject isFingureOverInteractables(Vector2 currentScreenTouchPosition)
    {
        /*
         *return appropriate gameObject on which fingure is touch  
         * or else return null
         */
        GameObject result = null;

        Ray touchRay = camera.ScreenPointToRay(currentScreenTouchPosition);
        List<RaycastHit> hits = Physics.RaycastAll(touchRay , rayTravelDistance).ToList();
        foreach(RaycastHit hit in hits)
        {
            if (interactableObjects.Contains(hit.transform.gameObject))
            {
                //current hit point has hit the interactable gameobject
                result = hit.transform.gameObject;
                break;
            }
        }

        return result;
    }

    private bool isTouchWithinPlayGround(Vector2 currentScreenTouchPosition , out RaycastHit hitOnPlayGround) 
    {
        bool result = false;

        /*
         * just initialize and set distance to -1 , which says this RaycastHit is not valid.
         */
        hitOnPlayGround = new RaycastHit(); 
        hitOnPlayGround.distance = -1;

        Ray touchRay = camera.ScreenPointToRay(currentScreenTouchPosition);
        List<RaycastHit> hits = Physics.RaycastAll(touchRay, rayTravelDistance).ToList();
        foreach (RaycastHit hit in hits)
        {
            if (hit.transform.gameObject == instantiatedPlayGround)
            {
                //current hit point has hit the playground gameobject
                hitOnPlayGround = hit;
                result = true;
                break;
            }
        }

        return result;
    }

    private Vector3 getAdjustedLocation(RaycastHit hit)
    { 
        Vector2 tempLocation = new Vector2(hit.point.x % gridSize, hit.point.z % gridSize);
        Vector3 result = Vector3.zero;

        if(tempLocation.x > (gridSize / 2))
        {
            result.x = (hit.point.x - tempLocation.x) + gridSize;
        }
        else
        {
            result.x = (hit.point.x - tempLocation.x);
        }

        if (tempLocation.y > (gridSize / 2))
        {
            result.z = (hit.point.z - tempLocation.y) + gridSize;
        }
        else
        {
            result.z = (hit.point.z - tempLocation.y);
        }
        result.y = hit.point.y;

        return result;

    }

    private bool isFingureTouchingPlaygroud(Ray position, out RaycastHit hitResult)
    {
        bool result = false;
        hitResult = new RaycastHit();
        hitResult.distance = -1;

        List<RaycastHit> hits = null;
        hits = Physics.RaycastAll(position).ToList();
        if(hits.Count > 0)
        {
            foreach(RaycastHit hit in hits)
            {
                if (hit.transform == instantiatedPlayGround.transform)
                {
                    hitResult = hit;
                    result = true;
                    break;
                }
            }
        }
        
        return result;
    }


    private void anchorChangedCallback(ARAnchorsChangedEventArgs args)
    {
        if (args.added.Contains(anchor))
        {
            instantiatedPlayGround = Instantiate(playGround , anchor.transform , false);
            mainEntity = Instantiate(Resources.Load<GameObject>(ARScreenHelper.Instance.duplicateResource.mainEntity.name),
                                     anchor.transform, false);
            Vector3 tempPos = mainEntity.transform.position;
            tempPos.y += mainEntity.transform.localScale.y / 2;
            mainEntity.transform.position = tempPos;

            playGroundPlaced = true;

            //allow player to add game assets
            placeNewObject = true;
            Debug.Log("Anchor and Playground placed");
            //LOAD PREVIOUS STORED SESSION DATA
            syncSessionDataAndInteractables();
        }
    }

    private void storeSessionDataToFile(string filePath)
    {
        StreamWriter sw = File.CreateText(filePath);
        string data = JsonConvert.SerializeObject(sessionData, Formatting.Indented);
        sw.WriteLine(data);
        sw.Close();
        Debug.Log(data);
    }

    private void fetchSessionDataFromFile(string filePath)
    {
        /*
        if (!File.Exists(filePath))
        {
            Debug.Log("No such fule exist in device");
            return;
        }

        string data = File.ReadAllText(filePath);
        sessionData = JsonConvert.DeserializeObject<Dictionary<string, Dictionary<string, List<float>>>>(data);

        Debug.Log(data);
        */
    }


    private void updateSessionData(GameObject obj)
    {
        //TODO : CHANGE THIS FUNCTION SO THAT IT CAN UPDATE INDIVIDUAL GAMEOBJECT

        Dictionary<string, List<float>> assetTransformData = new Dictionary<string, List<float>>();

        int index = 1;
        foreach(GameObject asset in interactableObjects)
        {
            string assetName = asset.name + index;
            //if this asset not present in our stored file, create an empty entry of it.
            if (!sessionData.ContainsKey(assetName))
            {
                sessionData.Add(assetName, null);
            }

            assetTransformData = new Dictionary<string, List<float>>();

            List<float> data = new List<float>
            {
                asset.transform.localPosition.x,
                asset.transform.localPosition.y,
                asset.transform.localPosition.z
            };
            assetTransformData.Add(LOCAL_POSITION, data);

            /*
             * ALWAYS USE EULAR ANGLE TO MAKE CHANGES TO GAMEOBJECT ROTATION RATHER THAN QUATRENION
             * APPLING QUATRENION DIRECTLY TO GAMEOBJECT GIVES SOME UNEXPECTED RESULTS.
             * LET UNITY CONVERT EULAR ANGLES TO QUATRENION.
             */
            data = new List<float>
            {
                asset.transform.localEulerAngles.x,
                asset.transform.localEulerAngles.y,
                asset.transform.localEulerAngles.z
            };
            assetTransformData.Add(LOCAL_ROTATION, data);

            data = new List<float>
            {
                asset.transform.localScale.x,
                asset.transform.localScale.y,
                asset.transform.localScale.z
            };
            assetTransformData.Add(LOCAL_SCALE, data);

            sessionData[assetName] = assetTransformData;

            index++;
        }
    }

    private void syncSessionDataAndInteractables()
    {

        /*
         * CALL THIS FUNCTION ONLY WHEN ANCHOR IS ADDED, TO FLOOD INTERACTABLES
         * WITH PREVIOUSLY STORED SESSION DATA.
         */

        if (!playGroundPlaced || anchor == null)
        {
            return;
        }

        if (sessionData == null)
        {
            return;
        }

        foreach (KeyValuePair<string , Dictionary<string,List<float>>> asset in sessionData)
        {
            string currentAssetKey = asset.Key;
            Dictionary<string, List<float>> assetTransformData = asset.Value;
            float[] positionData = assetTransformData[LOCAL_POSITION].ToArray();
            float[] rotationData = assetTransformData[LOCAL_ROTATION].ToArray();
            float[] scaleData = assetTransformData[LOCAL_SCALE].ToArray();

            Vector3 localPosition = new Vector3(
                                        positionData[0], //x
                                        positionData[1], //y
                                        positionData[2] //z
                                    );
            Vector3 localRotation = new Vector3(
                                        rotationData[0], //x
                                        rotationData[1], //y
                                        rotationData[2] //z
                                    );
            Vector3 localScale = new Vector3(
                                        scaleData[0], //x
                                        scaleData[1], //y
                                        scaleData[2] //z
                                    );

            GameObject obj = Instantiate(assetPrefab, anchor.transform, false);
            obj.transform.localPosition = localPosition;
            obj.transform.localScale = localScale;
            obj.transform.localEulerAngles = localRotation;

            interactableObjects.Add(obj);

        }

    }

    private void OnGUI()
    {
        if (playGroundPlaced && interactableObjects.Count > 0)
        {
            placeNewObject = GUILayout.Toggle(placeNewObject, "PLACE NEW OBJECT", GUILayout.Width(400), GUILayout.Height(100)) ;
            
        }
        else
        {
            GUILayout.Label("Place PlayGround First AND Place One GameObject", GUILayout.Width(400), GUILayout.Height(100));
        }
        
        if(GUILayout.Button("Store Session Data", GUILayout.Width(400), GUILayout.Height(100)))
        {
            storeSessionDataToFile(FILE);
        }
    }

}
